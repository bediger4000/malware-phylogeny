#!/usr/bin/env php
<?php
include("GroupingImage.php");
include("BinaryTree.php");
include("Tree.php");

list($species_names, $distances) = read_matrix($argv[1]);
$size = count($distances);

print("Original distance matrix:\n");
print_matrix($distances);

$groupings = array();
foreach ($species_names as $name)
	$groupings[] = new LeafNode($name);

do {
print "-------------------\n";
	$Q = calculate_Q($distances, $size);
	if ($size != count($Q)) exit;
	print("Q matrix\n");
	print_matrix($Q);

	choose_smallest_Q($Q, $size, $minI, $minJ);
	print("Smallest Q at ($minI, $minJ)\n");
	if ($minI == $minJ) exit;

	$colsumI = 0;
	$colsumJ = 0;
	for ($k = 0; $k < $size; ++$k) {
		$colsumI += ($minI < $k)? $distances[$minI][$k]: $distances[$k][$minI];
		$colsumJ += ($minJ < $k)? $distances[$minJ][$k]: $distances[$k][$minJ];
	}

	$d1 = $distances[$minI][$minJ]/2.0 + ($colsumI - $colsumJ)/(2*$size - 4);
	$d2 = $distances[$minI][$minJ] - $d1;

	print("new grouping from $minI:$d1, $minJ:$d2\n");
	$newgroup = new InteriorNode();
	$newgroup->add_neighbor($groupings[$minI], $d1);
	$newgroup->add_neighbor($groupings[$minJ], $d2);

	// $newgroup placed at $new_idx. $other_idx eliminated.
	$new_idx = ($minI < $minJ)? $minI: $minJ;
	$other_idx = ($new_idx == $minI)? $minJ: $minI;
print("Put new grouping at $new_idx, eliminate $other_idx\n");

	$newgroupings = array();
	foreach ($groupings as $idx => $grouping) {
		if ($idx == $other_idx)
			continue;
		else if ($idx == $new_idx)
			$newgroupings[] = $newgroup;
		else
			$newgroupings[] = $grouping;
	}
	$groupings = $newgroupings;
print("Now have ". count($groupings) . " groupings\n");
print("\$size == $size\n");

	$distances = recalculate_distances($distances, $size, $minI, $minJ);
print("\$distances now sized ".count($distances)."\n");

	print("\nNew distance matrix:\n");
	print_matrix($distances);

	$size = count($distances);
	if ($size != count($groupings)) exit;

} while ($size > 3);

// $size == 3 at this point.
$b = ($distances[1][2] + $distances[0][1] - $distances[0][2])/2.0;
$a = $distances[0][1] - $b;
$c = $distances[1][2] - $b;

print("Distance to new node: $a\n");
print("Distance from node1 to new node: $b\n");
print("Distance from node2 to new node: $c\n");

$g = new InteriorNode();
$g->add_neighbor($groupings[0], $a);
$g->add_neighbor($groupings[1], $b);
$g->add_neighbor($groupings[2], $c);

function findoutgroup($node) {
	global $outgroup_name;
	global $outgroup_node;
	$cn = get_class($node);
	if ($cn == 'LeafNode') {
		if ($node->label == $outgroup_name) {
			$outgroup_node = $node;
			return;
		}
	}
}

function printnode($node) {
	$cn = get_class($node);
	if ($cn == 'InteriorNode') {
		if (!$node->n1->visited)
			print($node->get_label().' - '.$node->n1->get_label().": {$node->dist1}\n");
		if (!$node->n2->visited)
			print($node->get_label().' - '.$node->n2->get_label().": {$node->dist2}\n");
		if (!$node->n3->visited)
			print($node->get_label().' - '.$node->n3->get_label().": {$node->dist3}\n");
	} else if ($cn = 'LeafNode') {
		print("Leaf node \"{$node->label}\"\n");
	}
}

function genericnode($node) {
	$cn = get_class($node);
	if ($cn == 'InteriorNode') {
		if (!$node->n1->visited) {
		}
		if (!$node->n2->visited) {
		}
		if (!$node->n3->visited) {
		}
	} else if ($cn = 'LeafNode') {
	}
}

$outgroup_name = $argv[3];
$outgroup_node = null;

$g->traverse('findoutgroup');

// New root between $outgroup_node and its parent.

$right_node = $outgroup_node->parnt;

if ($right_node->n1 == $outgroup_node) {
	$outgroup_dist = $right_node->dist1;
} else if ($right_node->n2 == $outgroup_node) {
	$outgroup_dist = $right_node->dist2;
} else if ($right_node->n3 == $outgroup_node) {
	$outgroup_dist = $right_node->dist3;
}
$outgroup_node->visited = true;
$root = new BinaryTree();
$root->label = 'root';
$nleft = new BinaryTree();
$nleft->label = $outgroup_node->label;
$root->set_child($nleft, $outgroup_dist/2.0);
$right_node->construct_binary($root,  $outgroup_dist/2.0, $outgroup_node);
$outgroup_node->visited = false;

list($max_label_length, $leaf_node_count, $depth) = $root->traverse(0.0);
print("Max label length: $max_label_length, $leaf_node_count leaf nodes\n");
print("Max depth: $depth\n");

if (isset($argv[2])) {
	$width = 750;
	if (isset($argv[5]))
		$width = $argv[5];
	$height = 500;
	if (isset($argv[4]))
		$height = $argv[4];
	$img = $root->draw_image($height, $width, $leaf_node_count, $depth, $max_label_length);
	imagepng($img, $argv[2]);
	imagedestroy($img);
	print("PNG in $argv[2]\n");
}

exit;

function recalculate_distances($distances, $size, $minI, $minJ)
{
	if ($minI < $minJ) {
		$replacement = $minI;
		$other = $minJ;
	} else {
		$replacement = $minJ;
		$other = $minI;
	}
	// Recalculate distances array. Put
	// the new grouping at $new_idx.
	$newdistances = array();
	for ($i = 0; $i < $size; ++$i) {
		if ($i == $other) continue;
		$new_row = array();
		for ($j = 0; $j < $size; ++$j) {
			if ($j == $other) continue;
			// The order of these tests makes a big difference.
			if ($i == $j)
				$val = 0.0;
			else if ($i == $replacement)
				$val = ((int)$distances[$minI][$j] + (int)$distances[$minJ][$j] - (int)$distances[$minI][$minJ])/2.0;
			else if ($i > $j)
				$val = null;
			else
				$val = $distances[$i][$j];
			$new_row[] = $val;
		}
		$new_distances[] = $new_row;
	}
	return $new_distances;
}

function calculate_Q($distances, $N)
{
	$rowsums = array_fill(0, $N, 0);
	$colsums = array_fill(0, $N, 0);
	foreach ($distances as $i => $row) {
		foreach ($row as $j => $d) {
			$d = ($i < $j)? $d: $distances[$j][$i];
			$rowsums[$i] += $d;
			$colsums[$j] += $d;
		}
	}

	$Q = array();

	foreach ($distances as $i => $row) {
		$Q[$i] = array();
		foreach ($row as $j => $d) {
			if ($i == $j) continue;
			$d = ($i < $j)? $d: $distances[$j][$i];
			$Q[$i][$j] = ($N - 2)*$d - $rowsums[$i] - $colsums[$j];
		}
	}

	return $Q;
}

function print_matrix($m)
{
	$size = count($m);
	for ($i = 0; $i < $size; ++$i) {
		print("\t");
		for ($j = 0; $j < $size; ++$j)
			if (isset($m[$i][$j]))
				print($m[$i][$j]."\t");
			else
				print("N\t");
		print("\n");
	}
	print("\n");
}

function choose_smallest_Q($Q, $size, &$minI, &$minJ)
{
	$minimum = 100;
	$minI    = -1;
	$minJ    = -1;

	for ($i = 0; $i < $size; ++$i) {
		for ($j = $i+1; $j < $size; ++$j) {
			$curr = $Q[$i][$j];
			if ($curr < $minimum) {
				$minimum = $curr;
				$minI = $i;
				$minJ = $j;
			}
		}
	}
}

function read_matrix($filename)
{
	$species_names = array();
	$M = array();

	$csv_handle = fopen($filename, "r");

	if ($csv_handle !== FALSE) {
		$species_names = fgetcsv($csv_handle);
		while (FALSE !== ($in = fgetcsv($csv_handle))) {
			$M[] = $in;
			
		}
		fclose($csv_handle);
	} else {
		print("Problem opening \"$filename\" for read\n");
		exit;
	}
	return array($species_names, $M);
}
